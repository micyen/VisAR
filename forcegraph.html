<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" href="./styles/style.css">
        <script src="https://unpkg.com/3d-force-graph"></script>
        </script>
    </head>
    <body>
        <div class="sidenav">
            <a href="./dashboard.html">
                <img src="imgs/Home_Icon.svg" alt="Home Icon" style="width:50px;height:50px;margin-left:auto;margin-right:auto;display:block;">
                <div style="text-align:center">
                    Home
                </div>
            </a>
            <a href="./forcegraph.html">
                <img src="imgs/Graph_Icon.svg" alt="Bipartite Icon" style="width:100px;height:100px;margin-left:auto;margin-right:auto;display:block;">
                <div style="text-align:center">
                    Graph
                </div>
            </a>
            <a href="./treemap.html">
                <img src="imgs/Treemap_Icon.svg" alt="Treemap Icon" style="width:100px;height:100px;margin-left:auto;margin-right:auto;display:block;">
                <div style="text-align:center">
                    Treemap
                </div>
            </a>
            <a href="./barchart.html">
                <img src="imgs/Barchart_Icon.svg" alt="Barchart Icon" style="width:100px;height:100px;margin-left:auto;margin-right:auto;display:block;">
                <div style="text-align:center">
                    Bar Chart
                </div>
            </a>
            <a href="./about.html">
                <img src="imgs/Info_Icon.svg" alt="About Icon" style="width:50px;height:50px;margin-left:auto;margin-right:auto;display:block;">
                <div style="text-align:center">
                    About
                </div>
            </a>
        </div>
        <div class="centerdiv">
            <div class="header">
                <h1>
                    VisAR
                </h1>
            </div>
            <div class="menu" id="menu"></div>
            <div id="forcegraph"></div>
        </div>
    </body>
</html>

<script type="module">

    selectDemographicInitiate();

    function selectDemographicInitiate() {

    fetch('https://faers-proj.s3.amazonaws.com/Data/DrugList.txt')
    .then((response) => response.text())
    .then((text) => {
        var druglist = text.split("\n");
        // const parent = document.getElementById("charts");
        // const menu = document.getElementById("menu");
        // menu.replaceChildren();
        // parent.replaceChildren();

        const select = document.createElement("select");
        select.id = "drug";

        for (var i = 0; i < druglist.length; i++) {
            var option = document.createElement("option");
            option.value = druglist[i].trim();
            option.text = druglist[i].trim();
            select.appendChild(option);
        }

        return select
    })
    .then((drugSelect) => {
        const parent = document.getElementById("menu");
        const form = document.createElement('form');

        const drugLabel = document.createElement('label');
        drugLabel.textContent = 'Drug: ';
        drugLabel.appendChild(drugSelect);

        const distanceLabel = document.createElement('label');
        distanceLabel.textContent = 'Distance (from Source Drug Node): ';
        const distanceInput = document.createElement('input');
        distanceInput.type = 'number';
        distanceInput.min = 0;
        distanceInput.placeholder = 'Distance';
        distanceInput.id = 'distance';

        const minWtLabel = document.createElement('label');
        minWtLabel.textContent = 'Minimum Edge Weight (Number of Cases): ';
        const weightInput = document.createElement('input');
        weightInput.type = 'number';
        weightInput.min = 0;
        weightInput.placeholder = 'Minimum Weight';
        weightInput.id = 'minWt';

        const submitButton = document.createElement('input');
        submitButton.type = 'submit';
        submitButton.value = 'Submit';

        form.appendChild(drugLabel);
        form.appendChild(document.createElement('br'));
        form.appendChild(document.createElement('br'));
        form.appendChild(distanceLabel);
        form.appendChild(distanceInput);
        form.appendChild(document.createElement('br'));
        form.appendChild(document.createElement('br'));
        form.appendChild(minWtLabel);
        form.appendChild(weightInput);
        form.appendChild(document.createElement('br'));
        form.appendChild(document.createElement('br'));
        form.appendChild(submitButton);
        parent.appendChild(form);

        form.addEventListener('submit', (event) => {
            event.preventDefault();

            const drug = document.getElementById("drug").value;
            const distance = document.getElementById("distance").valueAsNumber;
            const minWt = document.getElementById("minWt").valueAsNumber;

            const parameterJSON = JSON.stringify({"drug": drug, "distance": distance, "minWt":minWt});
            console.log(parameterJSON);

            fetch('http://ec2-44-212-66-70.compute-1.amazonaws.com:5000/forceGraph', {
                method: 'POST',
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                body: parameterJSON
            })
            .then((response) => {
                try {
                    const text = response.text()
                    .then((t) => {
                        if(t === "ERROR"){
                            alert("ERROR: Check all fields are filled correctly");
                        }
                        else {
                            const jsonBody = JSON.parse(JSON.parse(t)['body']);
                            console.log(jsonBody);
                            const nodes = jsonBody['nodes'];
                            const links = jsonBody['links'];

                            console.log(nodes.length);
                            console.log(links.length);

                            if(nodes.length > 4000 || links.length > 1000) {
                                if(true){
                                    if(confirm("This graph might be too large to render! Render in click to expand mode?")){
                                        renderLargeGraph(jsonBody, drug);
                                    }
                                }
                                else {
                                    renderGraph(jsonBody, drug);
                                }  
                            }                          
                        }
                    })
                }
                catch(err) {
                    alert(err);
                }
            });
        });
    })}

    function renderGraph(jsonBody, drug) {
        const elem = document.getElementById('forcegraph');
        const myGraph = ForceGraph3D();

        // cross-link node objects
        jsonBody.links.forEach(link => {
            var a = jsonBody.nodes.filter(node => {
                return node.id === link.source
            })[0];
            var b = jsonBody.nodes.filter(node => {
                return node.id === link.target
            })[0];
            !a.neighbors && (a.neighbors = []);
            !b.neighbors && (b.neighbors = []);
            a.neighbors.push(b);
            b.neighbors.push(a);

            !a.links && (a.links = []);
            !b.links && (b.links = []);
            a.links.push(link);
            b.links.push(link);
        });

        console.log(jsonBody);

        const highlightNodes = new Set();
        const highlightLinks = new Set();
        let hoverNode = null;

        const selectedNodes = new Set();

        myGraph(elem)
        .warmupTicks(200)
        .graphData(jsonBody)
        .nodeColor(node => {
            if (node === hoverNode) {
                return 'red';
            }
            else if (highlightNodes.has(node)){
                return 'purple';
            }
            else if (selectedNodes.has(node)){
                return 'yellow';
            }
            else{
                return 'steelblue';
            }
        })
        .linkWidth(link => highlightLinks.has(link) ? 4 : 1)
        .linkDirectionalParticles(link => highlightLinks.has(link) ? 4 : 0)
        .linkDirectionalParticleWidth(4)
        .nodeLabel(node => `${node.name}`) // change to actual node name
        .linkLabel(link => `${link.value}`) // change to actual link name
        .nodeVal(node => {
            if(node.name == drug){
                return 10;
            }
            else {
                return 1;
            }
        })
        .onNodeHover(node => {
          // no state change
          if ((!node && !highlightNodes.size) || (node && hoverNode === node)) return;

          highlightNodes.clear();
          highlightLinks.clear();
          if (node) {
            highlightNodes.add(node);
            node.neighbors.forEach(neighbor => highlightNodes.add(neighbor));
            node.links.forEach(link => highlightLinks.add(link));
          }

          hoverNode = node || null;

          updateHighlight();
        })
        .onLinkHover(link => {
          highlightNodes.clear();
          highlightLinks.clear();

          if (link) {
            highlightLinks.add(link);
            highlightNodes.add(link.source);
            highlightNodes.add(link.target);
          }

          updateHighlight();
        })
        .onNodeRightClick((node, event) => {
          if (event.ctrlKey || event.shiftKey || event.altKey) { // multi-selection
            selectedNodes.has(node) ? selectedNodes.delete(node) : selectedNodes.add(node);
          } else { // single-selection
            const untoggle = selectedNodes.has(node) && selectedNodes.size === 1;
            selectedNodes.clear();
            !untoggle && selectedNodes.add(node);
          }

          myGraph.nodeColor(myGraph.nodeColor()); // update color of selected nodes
        
        })
        .onNodeClick((node) => {
          const distance = 40;
          const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);

          const newPos = node.x || node.y || node.z
            ? { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }
            : { x: 0, y: 0, z: distance }; // special case if node is in (0,0,0)

          myGraph.cameraPosition(
            newPos, // new position
            node, // lookAt ({ x, y, z })
            3000  // ms transition duration
          );
        })
        .onNodeDrag((node, translate) => {
          if (selectedNodes.has(node)) { // moving a selected node
            [...selectedNodes]
              .filter(selNode => selNode !== node) // don't touch node being dragged
              .forEach(node => ['x', 'y', 'z'].forEach(coord => node[`f${coord}`] = node[coord] + translate[coord])); // translate other nodes by same amount
          }
        })
        .onNodeDragEnd(node => {
          if (selectedNodes.has(node)) { // finished moving a selected node
            [...selectedNodes]
              .filter(selNode => selNode !== node) // don't touch node being dragged
              .forEach(node => ['x', 'y', 'z'].forEach(coord => node[`f${coord}`] = undefined)); // unfix controlled nodes
          }
        })
        .onBackgroundRightClick(() => {
            myGraph.zoomToFit(400);
        });
        //TODO: label edges and other stuff

        function updateHighlight() {
            // trigger update of highlighted objects in scene
            myGraph
            .nodeColor(myGraph.nodeColor())
            .linkWidth(myGraph.linkWidth())
            .linkDirectionalParticles(myGraph.linkDirectionalParticles());
            //.linkColor(myGraph.)
        }

        // myGraph.onEngineStop(() => myGraph.zoomToFit(400));
    }

    function renderLargeGraph(jsonBody, drug) {
        const elem = document.getElementById('forcegraph');
        const myGraph = ForceGraph3D();

        // cross-link node objects
        jsonBody.links.forEach(link => {
            var a = jsonBody.nodes.filter(node => {
                return node.id === link.source
            })[0];
            var b = jsonBody.nodes.filter(node => {
                return node.id === link.target
            })[0];
            !a.neighbors && (a.neighbors = []);
            !b.neighbors && (b.neighbors = []);
            a.neighbors.push(b);
            b.neighbors.push(a);

            !a.links && (a.links = []);
            !b.links && (b.links = []);
            a.links.push(link);
            b.links.push(link);
        });

        console.log(jsonBody);

        const highlightNodes = new Set();
        const highlightLinks = new Set();
        let hoverNode = null;

        const selectedNodes = new Set();

        myGraph(elem)
        .warmupTicks(200)
        .graphData(jsonBody)
        .nodeColor(node => {
            if (node === hoverNode) {
                return 'red';
            }
            else if (highlightNodes.has(node)){
                return 'purple';
            }
            else if (selectedNodes.has(node)){
                return 'yellow';
            }
            else{
                return 'steelblue';
            }
        })
        .linkWidth(link => highlightLinks.has(link) ? 4 : 1)
        .linkDirectionalParticles(link => highlightLinks.has(link) ? 4 : 0)
        .linkDirectionalParticleWidth(4)
        .nodeLabel(node => `${node.name}`) // change to actual node name
        .linkLabel(link => `${link.value}`) // change to actual link name
        .nodeVal(node => {
            if(node.name == drug){
                return 10;
            }
            else {
                return 1;
            }
        })
        .onNodeHover(node => {
          // no state change
          if ((!node && !highlightNodes.size) || (node && hoverNode === node)) return;

          highlightNodes.clear();
          highlightLinks.clear();
          if (node) {
            highlightNodes.add(node);
            node.neighbors.forEach(neighbor => highlightNodes.add(neighbor));
            node.links.forEach(link => highlightLinks.add(link));
          }

          hoverNode = node || null;

          updateHighlight();
        })
        .onLinkHover(link => {
          highlightNodes.clear();
          highlightLinks.clear();

          if (link) {
            highlightLinks.add(link);
            highlightNodes.add(link.source);
            highlightNodes.add(link.target);
          }

          updateHighlight();
        })
        .onNodeRightClick((node, event) => {
          if (event.ctrlKey || event.shiftKey || event.altKey) { // multi-selection
            selectedNodes.has(node) ? selectedNodes.delete(node) : selectedNodes.add(node);
          } else { // single-selection
            const untoggle = selectedNodes.has(node) && selectedNodes.size === 1;
            selectedNodes.clear();
            !untoggle && selectedNodes.add(node);
          }

          myGraph.nodeColor(myGraph.nodeColor()); // update color of selected nodes
        
        })
        .onNodeClick((node) => {
          const distance = 40;
          const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);

          const newPos = node.x || node.y || node.z
            ? { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }
            : { x: 0, y: 0, z: distance }; // special case if node is in (0,0,0)

          myGraph.cameraPosition(
            newPos, // new position
            node, // lookAt ({ x, y, z })
            3000  // ms transition duration
          );
        })
        .onNodeDrag((node, translate) => {
          if (selectedNodes.has(node)) { // moving a selected node
            [...selectedNodes]
              .filter(selNode => selNode !== node) // don't touch node being dragged
              .forEach(node => ['x', 'y', 'z'].forEach(coord => node[`f${coord}`] = node[coord] + translate[coord])); // translate other nodes by same amount
          }
        })
        .onNodeDragEnd(node => {
          if (selectedNodes.has(node)) { // finished moving a selected node
            [...selectedNodes]
              .filter(selNode => selNode !== node) // don't touch node being dragged
              .forEach(node => ['x', 'y', 'z'].forEach(coord => node[`f${coord}`] = undefined)); // unfix controlled nodes
          }
        })
        .onBackgroundRightClick(() => {
            myGraph.zoomToFit(400);
        });
        //TODO: label edges and other stuff

        function updateHighlight() {
            // trigger update of highlighted objects in scene
            myGraph
            .nodeColor(myGraph.nodeColor())
            .linkWidth(myGraph.linkWidth())
            .linkDirectionalParticles(myGraph.linkDirectionalParticles());
            //.linkColor(myGraph.)
        }

        // myGraph.onEngineStop(() => myGraph.zoomToFit(400));
    }
</script>